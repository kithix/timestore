// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package timestore

import "time"

type FixedBoolSamples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []bool
	times       []time.Time
}

func (s *FixedBoolSamples) Len() int {
	return len(s.data)
}

func (s *FixedBoolSamples) All() ([]bool, []time.Time) {
	return s.data, s.times
}

func (s *FixedBoolSamples) Add(t time.Time, data bool) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedBoolSamples) Earliest() (bool, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedBoolSamples) Latest() (bool, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedBoolSamples) AllBefore(t time.Time) ([]bool, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []bool{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedBoolSamples) AllAfter(t time.Time) ([]bool, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []bool{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedBoolSamples) ClosestBefore(t time.Time) (bool, time.Time) {
	var d bool
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedBoolSamples) ClosestAfter(t time.Time) (bool, time.Time) {
	var d bool
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedBoolSamples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewBoolFixed(since time.Time, granularity, keepFor time.Duration) *FixedBoolSamples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedBoolSamples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]bool, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedByteSamples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []byte
	times       []time.Time
}

func (s *FixedByteSamples) Len() int {
	return len(s.data)
}

func (s *FixedByteSamples) All() ([]byte, []time.Time) {
	return s.data, s.times
}

func (s *FixedByteSamples) Add(t time.Time, data byte) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedByteSamples) Earliest() (byte, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedByteSamples) Latest() (byte, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedByteSamples) AllBefore(t time.Time) ([]byte, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []byte{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedByteSamples) AllAfter(t time.Time) ([]byte, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []byte{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedByteSamples) ClosestBefore(t time.Time) (byte, time.Time) {
	var d byte
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedByteSamples) ClosestAfter(t time.Time) (byte, time.Time) {
	var d byte
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedByteSamples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewByteFixed(since time.Time, granularity, keepFor time.Duration) *FixedByteSamples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedByteSamples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]byte, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedComplex128Samples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []complex128
	times       []time.Time
}

func (s *FixedComplex128Samples) Len() int {
	return len(s.data)
}

func (s *FixedComplex128Samples) All() ([]complex128, []time.Time) {
	return s.data, s.times
}

func (s *FixedComplex128Samples) Add(t time.Time, data complex128) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedComplex128Samples) Earliest() (complex128, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedComplex128Samples) Latest() (complex128, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedComplex128Samples) AllBefore(t time.Time) ([]complex128, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []complex128{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedComplex128Samples) AllAfter(t time.Time) ([]complex128, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []complex128{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedComplex128Samples) ClosestBefore(t time.Time) (complex128, time.Time) {
	var d complex128
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedComplex128Samples) ClosestAfter(t time.Time) (complex128, time.Time) {
	var d complex128
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedComplex128Samples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewComplex128Fixed(since time.Time, granularity, keepFor time.Duration) *FixedComplex128Samples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedComplex128Samples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]complex128, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedComplex64Samples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []complex64
	times       []time.Time
}

func (s *FixedComplex64Samples) Len() int {
	return len(s.data)
}

func (s *FixedComplex64Samples) All() ([]complex64, []time.Time) {
	return s.data, s.times
}

func (s *FixedComplex64Samples) Add(t time.Time, data complex64) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedComplex64Samples) Earliest() (complex64, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedComplex64Samples) Latest() (complex64, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedComplex64Samples) AllBefore(t time.Time) ([]complex64, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []complex64{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedComplex64Samples) AllAfter(t time.Time) ([]complex64, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []complex64{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedComplex64Samples) ClosestBefore(t time.Time) (complex64, time.Time) {
	var d complex64
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedComplex64Samples) ClosestAfter(t time.Time) (complex64, time.Time) {
	var d complex64
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedComplex64Samples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewComplex64Fixed(since time.Time, granularity, keepFor time.Duration) *FixedComplex64Samples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedComplex64Samples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]complex64, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedErrorSamples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []error
	times       []time.Time
}

func (s *FixedErrorSamples) Len() int {
	return len(s.data)
}

func (s *FixedErrorSamples) All() ([]error, []time.Time) {
	return s.data, s.times
}

func (s *FixedErrorSamples) Add(t time.Time, data error) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedErrorSamples) Earliest() (error, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedErrorSamples) Latest() (error, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedErrorSamples) AllBefore(t time.Time) ([]error, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []error{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedErrorSamples) AllAfter(t time.Time) ([]error, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []error{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedErrorSamples) ClosestBefore(t time.Time) (error, time.Time) {
	var d error
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedErrorSamples) ClosestAfter(t time.Time) (error, time.Time) {
	var d error
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedErrorSamples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewErrorFixed(since time.Time, granularity, keepFor time.Duration) *FixedErrorSamples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedErrorSamples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]error, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedFloat32Samples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []float32
	times       []time.Time
}

func (s *FixedFloat32Samples) Len() int {
	return len(s.data)
}

func (s *FixedFloat32Samples) All() ([]float32, []time.Time) {
	return s.data, s.times
}

func (s *FixedFloat32Samples) Add(t time.Time, data float32) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedFloat32Samples) Earliest() (float32, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedFloat32Samples) Latest() (float32, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedFloat32Samples) AllBefore(t time.Time) ([]float32, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []float32{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedFloat32Samples) AllAfter(t time.Time) ([]float32, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []float32{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedFloat32Samples) ClosestBefore(t time.Time) (float32, time.Time) {
	var d float32
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedFloat32Samples) ClosestAfter(t time.Time) (float32, time.Time) {
	var d float32
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedFloat32Samples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewFloat32Fixed(since time.Time, granularity, keepFor time.Duration) *FixedFloat32Samples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedFloat32Samples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]float32, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedFloat64Samples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []float64
	times       []time.Time
}

func (s *FixedFloat64Samples) Len() int {
	return len(s.data)
}

func (s *FixedFloat64Samples) All() ([]float64, []time.Time) {
	return s.data, s.times
}

func (s *FixedFloat64Samples) Add(t time.Time, data float64) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedFloat64Samples) Earliest() (float64, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedFloat64Samples) Latest() (float64, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedFloat64Samples) AllBefore(t time.Time) ([]float64, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []float64{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedFloat64Samples) AllAfter(t time.Time) ([]float64, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []float64{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedFloat64Samples) ClosestBefore(t time.Time) (float64, time.Time) {
	var d float64
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedFloat64Samples) ClosestAfter(t time.Time) (float64, time.Time) {
	var d float64
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedFloat64Samples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewFloat64Fixed(since time.Time, granularity, keepFor time.Duration) *FixedFloat64Samples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedFloat64Samples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]float64, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedIntSamples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []int
	times       []time.Time
}

func (s *FixedIntSamples) Len() int {
	return len(s.data)
}

func (s *FixedIntSamples) All() ([]int, []time.Time) {
	return s.data, s.times
}

func (s *FixedIntSamples) Add(t time.Time, data int) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedIntSamples) Earliest() (int, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedIntSamples) Latest() (int, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedIntSamples) AllBefore(t time.Time) ([]int, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []int{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedIntSamples) AllAfter(t time.Time) ([]int, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []int{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedIntSamples) ClosestBefore(t time.Time) (int, time.Time) {
	var d int
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedIntSamples) ClosestAfter(t time.Time) (int, time.Time) {
	var d int
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedIntSamples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewIntFixed(since time.Time, granularity, keepFor time.Duration) *FixedIntSamples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedIntSamples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]int, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedInt16Samples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []int16
	times       []time.Time
}

func (s *FixedInt16Samples) Len() int {
	return len(s.data)
}

func (s *FixedInt16Samples) All() ([]int16, []time.Time) {
	return s.data, s.times
}

func (s *FixedInt16Samples) Add(t time.Time, data int16) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedInt16Samples) Earliest() (int16, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedInt16Samples) Latest() (int16, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedInt16Samples) AllBefore(t time.Time) ([]int16, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []int16{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedInt16Samples) AllAfter(t time.Time) ([]int16, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []int16{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedInt16Samples) ClosestBefore(t time.Time) (int16, time.Time) {
	var d int16
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedInt16Samples) ClosestAfter(t time.Time) (int16, time.Time) {
	var d int16
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedInt16Samples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewInt16Fixed(since time.Time, granularity, keepFor time.Duration) *FixedInt16Samples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedInt16Samples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]int16, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedInt32Samples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []int32
	times       []time.Time
}

func (s *FixedInt32Samples) Len() int {
	return len(s.data)
}

func (s *FixedInt32Samples) All() ([]int32, []time.Time) {
	return s.data, s.times
}

func (s *FixedInt32Samples) Add(t time.Time, data int32) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedInt32Samples) Earliest() (int32, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedInt32Samples) Latest() (int32, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedInt32Samples) AllBefore(t time.Time) ([]int32, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []int32{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedInt32Samples) AllAfter(t time.Time) ([]int32, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []int32{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedInt32Samples) ClosestBefore(t time.Time) (int32, time.Time) {
	var d int32
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedInt32Samples) ClosestAfter(t time.Time) (int32, time.Time) {
	var d int32
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedInt32Samples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewInt32Fixed(since time.Time, granularity, keepFor time.Duration) *FixedInt32Samples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedInt32Samples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]int32, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedInt64Samples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []int64
	times       []time.Time
}

func (s *FixedInt64Samples) Len() int {
	return len(s.data)
}

func (s *FixedInt64Samples) All() ([]int64, []time.Time) {
	return s.data, s.times
}

func (s *FixedInt64Samples) Add(t time.Time, data int64) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedInt64Samples) Earliest() (int64, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedInt64Samples) Latest() (int64, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedInt64Samples) AllBefore(t time.Time) ([]int64, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []int64{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedInt64Samples) AllAfter(t time.Time) ([]int64, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []int64{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedInt64Samples) ClosestBefore(t time.Time) (int64, time.Time) {
	var d int64
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedInt64Samples) ClosestAfter(t time.Time) (int64, time.Time) {
	var d int64
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedInt64Samples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewInt64Fixed(since time.Time, granularity, keepFor time.Duration) *FixedInt64Samples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedInt64Samples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]int64, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedInt8Samples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []int8
	times       []time.Time
}

func (s *FixedInt8Samples) Len() int {
	return len(s.data)
}

func (s *FixedInt8Samples) All() ([]int8, []time.Time) {
	return s.data, s.times
}

func (s *FixedInt8Samples) Add(t time.Time, data int8) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedInt8Samples) Earliest() (int8, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedInt8Samples) Latest() (int8, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedInt8Samples) AllBefore(t time.Time) ([]int8, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []int8{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedInt8Samples) AllAfter(t time.Time) ([]int8, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []int8{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedInt8Samples) ClosestBefore(t time.Time) (int8, time.Time) {
	var d int8
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedInt8Samples) ClosestAfter(t time.Time) (int8, time.Time) {
	var d int8
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedInt8Samples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewInt8Fixed(since time.Time, granularity, keepFor time.Duration) *FixedInt8Samples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedInt8Samples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]int8, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedRuneSamples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []rune
	times       []time.Time
}

func (s *FixedRuneSamples) Len() int {
	return len(s.data)
}

func (s *FixedRuneSamples) All() ([]rune, []time.Time) {
	return s.data, s.times
}

func (s *FixedRuneSamples) Add(t time.Time, data rune) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedRuneSamples) Earliest() (rune, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedRuneSamples) Latest() (rune, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedRuneSamples) AllBefore(t time.Time) ([]rune, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []rune{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedRuneSamples) AllAfter(t time.Time) ([]rune, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []rune{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedRuneSamples) ClosestBefore(t time.Time) (rune, time.Time) {
	var d rune
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedRuneSamples) ClosestAfter(t time.Time) (rune, time.Time) {
	var d rune
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedRuneSamples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewRuneFixed(since time.Time, granularity, keepFor time.Duration) *FixedRuneSamples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedRuneSamples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]rune, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedStringSamples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []string
	times       []time.Time
}

func (s *FixedStringSamples) Len() int {
	return len(s.data)
}

func (s *FixedStringSamples) All() ([]string, []time.Time) {
	return s.data, s.times
}

func (s *FixedStringSamples) Add(t time.Time, data string) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedStringSamples) Earliest() (string, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedStringSamples) Latest() (string, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedStringSamples) AllBefore(t time.Time) ([]string, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []string{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedStringSamples) AllAfter(t time.Time) ([]string, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []string{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedStringSamples) ClosestBefore(t time.Time) (string, time.Time) {
	var d string
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedStringSamples) ClosestAfter(t time.Time) (string, time.Time) {
	var d string
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedStringSamples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewStringFixed(since time.Time, granularity, keepFor time.Duration) *FixedStringSamples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedStringSamples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]string, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedUintSamples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []uint
	times       []time.Time
}

func (s *FixedUintSamples) Len() int {
	return len(s.data)
}

func (s *FixedUintSamples) All() ([]uint, []time.Time) {
	return s.data, s.times
}

func (s *FixedUintSamples) Add(t time.Time, data uint) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedUintSamples) Earliest() (uint, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedUintSamples) Latest() (uint, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedUintSamples) AllBefore(t time.Time) ([]uint, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []uint{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedUintSamples) AllAfter(t time.Time) ([]uint, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []uint{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedUintSamples) ClosestBefore(t time.Time) (uint, time.Time) {
	var d uint
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedUintSamples) ClosestAfter(t time.Time) (uint, time.Time) {
	var d uint
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedUintSamples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewUintFixed(since time.Time, granularity, keepFor time.Duration) *FixedUintSamples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedUintSamples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]uint, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedUint16Samples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []uint16
	times       []time.Time
}

func (s *FixedUint16Samples) Len() int {
	return len(s.data)
}

func (s *FixedUint16Samples) All() ([]uint16, []time.Time) {
	return s.data, s.times
}

func (s *FixedUint16Samples) Add(t time.Time, data uint16) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedUint16Samples) Earliest() (uint16, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedUint16Samples) Latest() (uint16, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedUint16Samples) AllBefore(t time.Time) ([]uint16, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []uint16{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedUint16Samples) AllAfter(t time.Time) ([]uint16, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []uint16{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedUint16Samples) ClosestBefore(t time.Time) (uint16, time.Time) {
	var d uint16
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedUint16Samples) ClosestAfter(t time.Time) (uint16, time.Time) {
	var d uint16
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedUint16Samples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewUint16Fixed(since time.Time, granularity, keepFor time.Duration) *FixedUint16Samples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedUint16Samples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]uint16, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedUint32Samples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []uint32
	times       []time.Time
}

func (s *FixedUint32Samples) Len() int {
	return len(s.data)
}

func (s *FixedUint32Samples) All() ([]uint32, []time.Time) {
	return s.data, s.times
}

func (s *FixedUint32Samples) Add(t time.Time, data uint32) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedUint32Samples) Earliest() (uint32, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedUint32Samples) Latest() (uint32, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedUint32Samples) AllBefore(t time.Time) ([]uint32, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []uint32{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedUint32Samples) AllAfter(t time.Time) ([]uint32, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []uint32{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedUint32Samples) ClosestBefore(t time.Time) (uint32, time.Time) {
	var d uint32
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedUint32Samples) ClosestAfter(t time.Time) (uint32, time.Time) {
	var d uint32
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedUint32Samples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewUint32Fixed(since time.Time, granularity, keepFor time.Duration) *FixedUint32Samples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedUint32Samples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]uint32, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedUint64Samples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []uint64
	times       []time.Time
}

func (s *FixedUint64Samples) Len() int {
	return len(s.data)
}

func (s *FixedUint64Samples) All() ([]uint64, []time.Time) {
	return s.data, s.times
}

func (s *FixedUint64Samples) Add(t time.Time, data uint64) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedUint64Samples) Earliest() (uint64, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedUint64Samples) Latest() (uint64, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedUint64Samples) AllBefore(t time.Time) ([]uint64, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []uint64{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedUint64Samples) AllAfter(t time.Time) ([]uint64, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []uint64{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedUint64Samples) ClosestBefore(t time.Time) (uint64, time.Time) {
	var d uint64
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedUint64Samples) ClosestAfter(t time.Time) (uint64, time.Time) {
	var d uint64
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedUint64Samples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewUint64Fixed(since time.Time, granularity, keepFor time.Duration) *FixedUint64Samples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedUint64Samples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]uint64, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedUint8Samples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []uint8
	times       []time.Time
}

func (s *FixedUint8Samples) Len() int {
	return len(s.data)
}

func (s *FixedUint8Samples) All() ([]uint8, []time.Time) {
	return s.data, s.times
}

func (s *FixedUint8Samples) Add(t time.Time, data uint8) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedUint8Samples) Earliest() (uint8, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedUint8Samples) Latest() (uint8, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedUint8Samples) AllBefore(t time.Time) ([]uint8, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []uint8{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedUint8Samples) AllAfter(t time.Time) ([]uint8, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []uint8{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedUint8Samples) ClosestBefore(t time.Time) (uint8, time.Time) {
	var d uint8
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedUint8Samples) ClosestAfter(t time.Time) (uint8, time.Time) {
	var d uint8
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedUint8Samples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewUint8Fixed(since time.Time, granularity, keepFor time.Duration) *FixedUint8Samples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedUint8Samples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]uint8, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}

type FixedUintptrSamples struct {
	since       time.Time
	until       time.Time
	granularity time.Duration
	earliestPos *int
	latestPos   *int
	data        []uintptr
	times       []time.Time
}

func (s *FixedUintptrSamples) Len() int {
	return len(s.data)
}

func (s *FixedUintptrSamples) All() ([]uintptr, []time.Time) {
	return s.data, s.times
}

func (s *FixedUintptrSamples) Add(t time.Time, data uintptr) {
	pos := s.position(t)
	if s.earliestPos == nil || pos < *s.earliestPos {
		s.earliestPos = &pos
	}
	if s.latestPos == nil || pos > *s.latestPos {
		s.latestPos = &pos
	}
	s.data[pos] = data
}

func (s *FixedUintptrSamples) Earliest() (uintptr, time.Time) {
	if s.earliestPos == nil {
		return s.data[0], time.Time{}
	}
	return s.data[*s.earliestPos], s.times[*s.earliestPos]
}

func (s *FixedUintptrSamples) Latest() (uintptr, time.Time) {
	if s.latestPos == nil {
		return s.data[len(s.data)-1], time.Time{}
	}
	return s.data[*s.latestPos], s.times[*s.latestPos]
}

func (s *FixedUintptrSamples) AllBefore(t time.Time) ([]uintptr, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []uintptr{}, []time.Time{}
	}
	return s.data[:pos], s.times[:pos]
}

func (s *FixedUintptrSamples) AllAfter(t time.Time) ([]uintptr, []time.Time) {
	pos := s.position(t)
	if pos < 0 {
		return []uintptr{}, []time.Time{}
	}
	return s.data[pos:], s.times[pos:]
}

func (s *FixedUintptrSamples) ClosestBefore(t time.Time) (uintptr, time.Time) {
	var d uintptr
	pos := s.position(t)
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedUintptrSamples) ClosestAfter(t time.Time) (uintptr, time.Time) {
	var d uintptr
	pos := s.position(t) + 1
	if pos < 0 {
		return d, time.Time{}
	}
	return s.data[pos], s.times[pos]
}

func (s *FixedUintptrSamples) position(t time.Time) int {
	pos := workoutSamplePosition(s.granularity, s.since, t)
	if pos > len(s.data) {
		return -1
	}
	return pos
}

func NewUintptrFixed(since time.Time, granularity, keepFor time.Duration) *FixedUintptrSamples {
	until := since.Add(keepFor)
	amountOf := workoutSamplePosition(granularity, since, until)
	return &FixedUintptrSamples{
		since,
		until,
		granularity,
		nil,
		nil,
		make([]uintptr, amountOf),
		makeTimes(since, granularity, amountOf),
	}
}
