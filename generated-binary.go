// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package timestore

import (
	"sort"
	"time"
)

type BoolSamples struct {
	times []time.Time
	data  []bool
}

func (s *BoolSamples) Len() int {
	return len(s.data)
}

func (s *BoolSamples) All() ([]bool, []time.Time) {
	return s.data, s.times
}

func (s *BoolSamples) Add(t time.Time, data bool) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]bool{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]bool{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *BoolSamples) ClosestAfter(t time.Time) (bool, time.Time) {
	// Nil value for unable to find
	var v bool
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *BoolSamples) ClosestBefore(t time.Time) (bool, time.Time) {
	// Nil value for unable to find
	var v bool
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *BoolSamples) AllAfter(t time.Time) ([]bool, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []bool{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *BoolSamples) AllBefore(t time.Time) ([]bool, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []bool{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewBoolBinary() *BoolSamples {
	return &BoolSamples{
		times: []time.Time{},
		data:  []bool{},
	}
}

type ByteSamples struct {
	times []time.Time
	data  []byte
}

func (s *ByteSamples) Len() int {
	return len(s.data)
}

func (s *ByteSamples) All() ([]byte, []time.Time) {
	return s.data, s.times
}

func (s *ByteSamples) Add(t time.Time, data byte) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]byte{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]byte{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *ByteSamples) ClosestAfter(t time.Time) (byte, time.Time) {
	// Nil value for unable to find
	var v byte
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *ByteSamples) ClosestBefore(t time.Time) (byte, time.Time) {
	// Nil value for unable to find
	var v byte
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *ByteSamples) AllAfter(t time.Time) ([]byte, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []byte{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *ByteSamples) AllBefore(t time.Time) ([]byte, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []byte{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewByteBinary() *ByteSamples {
	return &ByteSamples{
		times: []time.Time{},
		data:  []byte{},
	}
}

type Complex128Samples struct {
	times []time.Time
	data  []complex128
}

func (s *Complex128Samples) Len() int {
	return len(s.data)
}

func (s *Complex128Samples) All() ([]complex128, []time.Time) {
	return s.data, s.times
}

func (s *Complex128Samples) Add(t time.Time, data complex128) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]complex128{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]complex128{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *Complex128Samples) ClosestAfter(t time.Time) (complex128, time.Time) {
	// Nil value for unable to find
	var v complex128
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Complex128Samples) ClosestBefore(t time.Time) (complex128, time.Time) {
	// Nil value for unable to find
	var v complex128
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Complex128Samples) AllAfter(t time.Time) ([]complex128, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []complex128{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *Complex128Samples) AllBefore(t time.Time) ([]complex128, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []complex128{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewComplex128Binary() *Complex128Samples {
	return &Complex128Samples{
		times: []time.Time{},
		data:  []complex128{},
	}
}

type Complex64Samples struct {
	times []time.Time
	data  []complex64
}

func (s *Complex64Samples) Len() int {
	return len(s.data)
}

func (s *Complex64Samples) All() ([]complex64, []time.Time) {
	return s.data, s.times
}

func (s *Complex64Samples) Add(t time.Time, data complex64) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]complex64{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]complex64{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *Complex64Samples) ClosestAfter(t time.Time) (complex64, time.Time) {
	// Nil value for unable to find
	var v complex64
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Complex64Samples) ClosestBefore(t time.Time) (complex64, time.Time) {
	// Nil value for unable to find
	var v complex64
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Complex64Samples) AllAfter(t time.Time) ([]complex64, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []complex64{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *Complex64Samples) AllBefore(t time.Time) ([]complex64, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []complex64{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewComplex64Binary() *Complex64Samples {
	return &Complex64Samples{
		times: []time.Time{},
		data:  []complex64{},
	}
}

type ErrorSamples struct {
	times []time.Time
	data  []error
}

func (s *ErrorSamples) Len() int {
	return len(s.data)
}

func (s *ErrorSamples) All() ([]error, []time.Time) {
	return s.data, s.times
}

func (s *ErrorSamples) Add(t time.Time, data error) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]error{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]error{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *ErrorSamples) ClosestAfter(t time.Time) (error, time.Time) {
	// Nil value for unable to find
	var v error
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *ErrorSamples) ClosestBefore(t time.Time) (error, time.Time) {
	// Nil value for unable to find
	var v error
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *ErrorSamples) AllAfter(t time.Time) ([]error, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []error{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *ErrorSamples) AllBefore(t time.Time) ([]error, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []error{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewErrorBinary() *ErrorSamples {
	return &ErrorSamples{
		times: []time.Time{},
		data:  []error{},
	}
}

type Float32Samples struct {
	times []time.Time
	data  []float32
}

func (s *Float32Samples) Len() int {
	return len(s.data)
}

func (s *Float32Samples) All() ([]float32, []time.Time) {
	return s.data, s.times
}

func (s *Float32Samples) Add(t time.Time, data float32) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]float32{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]float32{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *Float32Samples) ClosestAfter(t time.Time) (float32, time.Time) {
	// Nil value for unable to find
	var v float32
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Float32Samples) ClosestBefore(t time.Time) (float32, time.Time) {
	// Nil value for unable to find
	var v float32
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Float32Samples) AllAfter(t time.Time) ([]float32, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []float32{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *Float32Samples) AllBefore(t time.Time) ([]float32, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []float32{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewFloat32Binary() *Float32Samples {
	return &Float32Samples{
		times: []time.Time{},
		data:  []float32{},
	}
}

type Float64Samples struct {
	times []time.Time
	data  []float64
}

func (s *Float64Samples) Len() int {
	return len(s.data)
}

func (s *Float64Samples) All() ([]float64, []time.Time) {
	return s.data, s.times
}

func (s *Float64Samples) Add(t time.Time, data float64) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]float64{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]float64{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *Float64Samples) ClosestAfter(t time.Time) (float64, time.Time) {
	// Nil value for unable to find
	var v float64
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Float64Samples) ClosestBefore(t time.Time) (float64, time.Time) {
	// Nil value for unable to find
	var v float64
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Float64Samples) AllAfter(t time.Time) ([]float64, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []float64{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *Float64Samples) AllBefore(t time.Time) ([]float64, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []float64{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewFloat64Binary() *Float64Samples {
	return &Float64Samples{
		times: []time.Time{},
		data:  []float64{},
	}
}

type IntSamples struct {
	times []time.Time
	data  []int
}

func (s *IntSamples) Len() int {
	return len(s.data)
}

func (s *IntSamples) All() ([]int, []time.Time) {
	return s.data, s.times
}

func (s *IntSamples) Add(t time.Time, data int) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]int{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]int{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *IntSamples) ClosestAfter(t time.Time) (int, time.Time) {
	// Nil value for unable to find
	var v int
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *IntSamples) ClosestBefore(t time.Time) (int, time.Time) {
	// Nil value for unable to find
	var v int
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *IntSamples) AllAfter(t time.Time) ([]int, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []int{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *IntSamples) AllBefore(t time.Time) ([]int, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []int{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewIntBinary() *IntSamples {
	return &IntSamples{
		times: []time.Time{},
		data:  []int{},
	}
}

type Int16Samples struct {
	times []time.Time
	data  []int16
}

func (s *Int16Samples) Len() int {
	return len(s.data)
}

func (s *Int16Samples) All() ([]int16, []time.Time) {
	return s.data, s.times
}

func (s *Int16Samples) Add(t time.Time, data int16) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]int16{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]int16{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *Int16Samples) ClosestAfter(t time.Time) (int16, time.Time) {
	// Nil value for unable to find
	var v int16
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Int16Samples) ClosestBefore(t time.Time) (int16, time.Time) {
	// Nil value for unable to find
	var v int16
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Int16Samples) AllAfter(t time.Time) ([]int16, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []int16{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *Int16Samples) AllBefore(t time.Time) ([]int16, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []int16{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewInt16Binary() *Int16Samples {
	return &Int16Samples{
		times: []time.Time{},
		data:  []int16{},
	}
}

type Int32Samples struct {
	times []time.Time
	data  []int32
}

func (s *Int32Samples) Len() int {
	return len(s.data)
}

func (s *Int32Samples) All() ([]int32, []time.Time) {
	return s.data, s.times
}

func (s *Int32Samples) Add(t time.Time, data int32) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]int32{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]int32{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *Int32Samples) ClosestAfter(t time.Time) (int32, time.Time) {
	// Nil value for unable to find
	var v int32
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Int32Samples) ClosestBefore(t time.Time) (int32, time.Time) {
	// Nil value for unable to find
	var v int32
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Int32Samples) AllAfter(t time.Time) ([]int32, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []int32{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *Int32Samples) AllBefore(t time.Time) ([]int32, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []int32{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewInt32Binary() *Int32Samples {
	return &Int32Samples{
		times: []time.Time{},
		data:  []int32{},
	}
}

type Int64Samples struct {
	times []time.Time
	data  []int64
}

func (s *Int64Samples) Len() int {
	return len(s.data)
}

func (s *Int64Samples) All() ([]int64, []time.Time) {
	return s.data, s.times
}

func (s *Int64Samples) Add(t time.Time, data int64) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]int64{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]int64{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *Int64Samples) ClosestAfter(t time.Time) (int64, time.Time) {
	// Nil value for unable to find
	var v int64
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Int64Samples) ClosestBefore(t time.Time) (int64, time.Time) {
	// Nil value for unable to find
	var v int64
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Int64Samples) AllAfter(t time.Time) ([]int64, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []int64{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *Int64Samples) AllBefore(t time.Time) ([]int64, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []int64{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewInt64Binary() *Int64Samples {
	return &Int64Samples{
		times: []time.Time{},
		data:  []int64{},
	}
}

type Int8Samples struct {
	times []time.Time
	data  []int8
}

func (s *Int8Samples) Len() int {
	return len(s.data)
}

func (s *Int8Samples) All() ([]int8, []time.Time) {
	return s.data, s.times
}

func (s *Int8Samples) Add(t time.Time, data int8) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]int8{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]int8{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *Int8Samples) ClosestAfter(t time.Time) (int8, time.Time) {
	// Nil value for unable to find
	var v int8
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Int8Samples) ClosestBefore(t time.Time) (int8, time.Time) {
	// Nil value for unable to find
	var v int8
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Int8Samples) AllAfter(t time.Time) ([]int8, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []int8{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *Int8Samples) AllBefore(t time.Time) ([]int8, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []int8{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewInt8Binary() *Int8Samples {
	return &Int8Samples{
		times: []time.Time{},
		data:  []int8{},
	}
}

type RuneSamples struct {
	times []time.Time
	data  []rune
}

func (s *RuneSamples) Len() int {
	return len(s.data)
}

func (s *RuneSamples) All() ([]rune, []time.Time) {
	return s.data, s.times
}

func (s *RuneSamples) Add(t time.Time, data rune) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]rune{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]rune{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *RuneSamples) ClosestAfter(t time.Time) (rune, time.Time) {
	// Nil value for unable to find
	var v rune
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *RuneSamples) ClosestBefore(t time.Time) (rune, time.Time) {
	// Nil value for unable to find
	var v rune
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *RuneSamples) AllAfter(t time.Time) ([]rune, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []rune{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *RuneSamples) AllBefore(t time.Time) ([]rune, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []rune{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewRuneBinary() *RuneSamples {
	return &RuneSamples{
		times: []time.Time{},
		data:  []rune{},
	}
}

type StringSamples struct {
	times []time.Time
	data  []string
}

func (s *StringSamples) Len() int {
	return len(s.data)
}

func (s *StringSamples) All() ([]string, []time.Time) {
	return s.data, s.times
}

func (s *StringSamples) Add(t time.Time, data string) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]string{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]string{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *StringSamples) ClosestAfter(t time.Time) (string, time.Time) {
	// Nil value for unable to find
	var v string
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *StringSamples) ClosestBefore(t time.Time) (string, time.Time) {
	// Nil value for unable to find
	var v string
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *StringSamples) AllAfter(t time.Time) ([]string, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []string{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *StringSamples) AllBefore(t time.Time) ([]string, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []string{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewStringBinary() *StringSamples {
	return &StringSamples{
		times: []time.Time{},
		data:  []string{},
	}
}

type UintSamples struct {
	times []time.Time
	data  []uint
}

func (s *UintSamples) Len() int {
	return len(s.data)
}

func (s *UintSamples) All() ([]uint, []time.Time) {
	return s.data, s.times
}

func (s *UintSamples) Add(t time.Time, data uint) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]uint{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]uint{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *UintSamples) ClosestAfter(t time.Time) (uint, time.Time) {
	// Nil value for unable to find
	var v uint
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *UintSamples) ClosestBefore(t time.Time) (uint, time.Time) {
	// Nil value for unable to find
	var v uint
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *UintSamples) AllAfter(t time.Time) ([]uint, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []uint{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *UintSamples) AllBefore(t time.Time) ([]uint, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []uint{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewUintBinary() *UintSamples {
	return &UintSamples{
		times: []time.Time{},
		data:  []uint{},
	}
}

type Uint16Samples struct {
	times []time.Time
	data  []uint16
}

func (s *Uint16Samples) Len() int {
	return len(s.data)
}

func (s *Uint16Samples) All() ([]uint16, []time.Time) {
	return s.data, s.times
}

func (s *Uint16Samples) Add(t time.Time, data uint16) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]uint16{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]uint16{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *Uint16Samples) ClosestAfter(t time.Time) (uint16, time.Time) {
	// Nil value for unable to find
	var v uint16
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Uint16Samples) ClosestBefore(t time.Time) (uint16, time.Time) {
	// Nil value for unable to find
	var v uint16
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Uint16Samples) AllAfter(t time.Time) ([]uint16, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []uint16{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *Uint16Samples) AllBefore(t time.Time) ([]uint16, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []uint16{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewUint16Binary() *Uint16Samples {
	return &Uint16Samples{
		times: []time.Time{},
		data:  []uint16{},
	}
}

type Uint32Samples struct {
	times []time.Time
	data  []uint32
}

func (s *Uint32Samples) Len() int {
	return len(s.data)
}

func (s *Uint32Samples) All() ([]uint32, []time.Time) {
	return s.data, s.times
}

func (s *Uint32Samples) Add(t time.Time, data uint32) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]uint32{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]uint32{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *Uint32Samples) ClosestAfter(t time.Time) (uint32, time.Time) {
	// Nil value for unable to find
	var v uint32
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Uint32Samples) ClosestBefore(t time.Time) (uint32, time.Time) {
	// Nil value for unable to find
	var v uint32
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Uint32Samples) AllAfter(t time.Time) ([]uint32, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []uint32{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *Uint32Samples) AllBefore(t time.Time) ([]uint32, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []uint32{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewUint32Binary() *Uint32Samples {
	return &Uint32Samples{
		times: []time.Time{},
		data:  []uint32{},
	}
}

type Uint64Samples struct {
	times []time.Time
	data  []uint64
}

func (s *Uint64Samples) Len() int {
	return len(s.data)
}

func (s *Uint64Samples) All() ([]uint64, []time.Time) {
	return s.data, s.times
}

func (s *Uint64Samples) Add(t time.Time, data uint64) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]uint64{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]uint64{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *Uint64Samples) ClosestAfter(t time.Time) (uint64, time.Time) {
	// Nil value for unable to find
	var v uint64
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Uint64Samples) ClosestBefore(t time.Time) (uint64, time.Time) {
	// Nil value for unable to find
	var v uint64
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Uint64Samples) AllAfter(t time.Time) ([]uint64, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []uint64{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *Uint64Samples) AllBefore(t time.Time) ([]uint64, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []uint64{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewUint64Binary() *Uint64Samples {
	return &Uint64Samples{
		times: []time.Time{},
		data:  []uint64{},
	}
}

type Uint8Samples struct {
	times []time.Time
	data  []uint8
}

func (s *Uint8Samples) Len() int {
	return len(s.data)
}

func (s *Uint8Samples) All() ([]uint8, []time.Time) {
	return s.data, s.times
}

func (s *Uint8Samples) Add(t time.Time, data uint8) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]uint8{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]uint8{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *Uint8Samples) ClosestAfter(t time.Time) (uint8, time.Time) {
	// Nil value for unable to find
	var v uint8
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Uint8Samples) ClosestBefore(t time.Time) (uint8, time.Time) {
	// Nil value for unable to find
	var v uint8
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *Uint8Samples) AllAfter(t time.Time) ([]uint8, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []uint8{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *Uint8Samples) AllBefore(t time.Time) ([]uint8, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []uint8{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewUint8Binary() *Uint8Samples {
	return &Uint8Samples{
		times: []time.Time{},
		data:  []uint8{},
	}
}

type UintptrSamples struct {
	times []time.Time
	data  []uintptr
}

func (s *UintptrSamples) Len() int {
	return len(s.data)
}

func (s *UintptrSamples) All() ([]uintptr, []time.Time) {
	return s.data, s.times
}

func (s *UintptrSamples) Add(t time.Time, data uintptr) {
	// If this is our first data point or the new latest, add to the end
	if len(s.times) == 0 || s.times[len(s.times)-1].Before(t) {
		s.data = append(s.data, data)
		s.times = append(s.times, t)
		return
	}

	// If this is before our earliest sample, add it to the start
	if s.times[0].After(t) {
		s.data = append([]uintptr{data}, s.data...)
		s.times = append([]time.Time{t}, s.times...)
		return
	}

	// Binary search
	i := sort.Search(len(s.times)-1, func(i int) bool {
		return s.times[i].After(t)
	})
	s.data = append(s.data[:i], append([]uintptr{data}, s.data[i:]...)...)
	s.times = append(s.times[:i], append([]time.Time{t}, s.times[i:]...)...)
	return
}

func (s *UintptrSamples) ClosestAfter(t time.Time) (uintptr, time.Time) {
	// Nil value for unable to find
	var v uintptr
	i := indexAfter(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *UintptrSamples) ClosestBefore(t time.Time) (uintptr, time.Time) {
	// Nil value for unable to find
	var v uintptr
	i := indexBefore(s.times, t)
	if i < 0 {
		return v, time.Time{}
	}
	return s.data[i], s.times[i]
}

func (s *UintptrSamples) AllAfter(t time.Time) ([]uintptr, []time.Time) {
	i := indexAfter(s.times, t)
	if i < 0 {
		return []uintptr{}, []time.Time{}
	}
	return s.data[i:], s.times[i:]
}

func (s *UintptrSamples) AllBefore(t time.Time) ([]uintptr, []time.Time) {
	i := indexBefore(s.times, t)
	if i < 0 {
		return []uintptr{}, []time.Time{}
	}
	return s.data[:i+1], s.times[:i+1]
}

func NewUintptrBinary() *UintptrSamples {
	return &UintptrSamples{
		times: []time.Time{},
		data:  []uintptr{},
	}
}
